{"version":3,"sources":["visualizations/D3Dots.js","visualizations/D3Axes.js","visualizations/Dots.jsx","visualizations/Visualization.jsx","App.js","serviceWorker.js","index.js"],"names":["D3Dots","drawDots","ctx","nodes","forEach","node","beginPath","arc","x","y","Math","PI","fillStyle","fill","drawHorizontalLinks","children","child","childNode","cluster","strokeStyle","moveTo","midX","bezierCurveTo","stroke","D3Axes","drawAxes","xAxisRef","_","xScale","xAxis","d3","tickFormat","d","ticks","every","STATES","GRAPH","BROWNIAN","LINKS","CIRCLE","RADIAL","SINGAPORE","stateKeys","Object","keys","WEEK","Dots","data","height","width","useState","displayState","setDisplayState","setNodes","simulation","setSimulation","timer","setTimer","ref","useRef","yAxisRef","useEffect","dataNodes","map","dist","random","min","locAngle","fillColor","status","cos","sin","brownian","dailyGraph","gatherNodes","radialGraph","linkGraph","singapore","resetState","stop","current","selectAll","remove","replusion","strength","yForce","xForce","sim","force","alphaMin","velocityDecay","on","context","getContext","clearRect","dateConfirmed","yScale","dayNo","firstDay","lastDay","weeks","Array","ceil","week","index","floor","weekNo","weekAngle","console","log","rScale","length","ANIMATION_SPAN","startX","startY","targetX","targetY","newTimer","elapsed","ratio","i","ellipse","treeY","vx","vy","d3ForceSurface","surfaces","from","to","heightExtent","sgY","widthExtent","sgX","heightSg","widthSg","scale","xOffset","yOffset","style","position","transform","onClick","e","preventDefault","newDisplayState","values","indexOf","clickHandler","Visualization","window","innerHeight","innerWidth","App","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.87ecc2ae.chunk.js","sourcesContent":["// Helper method to draw the dots and horizontal/vertical links,\n// if any.\nconst D3Dots = {\n  drawDots(ctx, nodes) {\n    nodes.forEach((node) => {\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, 3, 0, 2 * Math.PI, false);\n      ctx.fillStyle = node.fill;\n      ctx.fill();\n    });\n  },\n\n  drawHorizontalLinks(ctx, nodes) {\n    nodes.forEach((node) => {\n      if (node.children) {\n        node.children.forEach((child) => {\n          const childNode = nodes[child - 1];\n          ctx.beginPath();\n          if (node.cluster) {\n            if (node.cluster === \"F\") ctx.strokeStyle = \"green\";\n            else if (node.cluster === \"C\") ctx.strokeStyle = \"red\";\n            else ctx.strokeStyle = \"blue\";\n          }\n          ctx.moveTo(node.x, node.y);\n          const midX = (childNode.x + node.x) / 2;\n          ctx.bezierCurveTo(\n            midX,\n            node.y,\n            midX,\n            childNode.y,\n            childNode.x,\n            childNode.y\n          );\n          ctx.stroke();\n        });\n      }\n    });\n  },\n};\n\nexport default D3Dots;\n","import * as d3 from \"d3\";\n\n// Draws the Axes via d3\nconst D3Axes = {\n  drawAxes(xAxisRef, _, xScale) {\n    const xAxis = d3.axisBottom(xScale).tickFormat((d) => d);\n    xAxis.ticks(d3.utcDay.every(1));\n    xAxis.tickFormat(d3.timeFormat(\"%e\"));\n\n    xAxis(xAxisRef);\n  },\n};\n\nexport default D3Axes;\n","import React, { useState, useRef, useEffect } from \"react\";\nimport * as d3 from \"d3\";\nimport D3Dots from \"./D3Dots\";\nimport D3Axes from \"./D3Axes\";\nimport d3ForceSurface from \"d3-force-surface\";\n\n// Simulate an enum for the various states\nconst STATES = {\n  GRAPH: \"GRAPH\",\n  BROWNIAN: \"BROWNIAN\",\n  LINKS: \"LINKS\",\n  CIRCLE: \"CIRCLE\",\n  RADIAL: \"RADIAL\",\n  SINGAPORE: \"SINGAPORE\",\n};\n\n// debug only, will be removed\nconst stateKeys = Object.keys(STATES);\n\n// Global variables\nconst PADDING = 50;\nconst DAY = 1000 * 24 * 60 * 60;\nconst WEEK = 7 * DAY;\n\nconst Dots = ({ data, height, width }) => {\n  const [displayState, setDisplayState] = useState(STATES.SINGAPORE);\n  const [nodes, setNodes] = useState([]);\n  const [simulation, setSimulation] = useState(null);\n  const [timer, setTimer] = useState(null);\n\n  const ref = useRef(null);\n  const xAxisRef = useRef(null);\n  const yAxisRef = useRef(null);\n\n  // Re-initialize nodes everytime data, height, or width is changed.\n  useEffect(() => {\n    const dataNodes = data.map((d) => {\n      const dist = (Math.random() * Math.min(height, width)) / 5;\n      const locAngle = Math.random() * Math.PI * 2;\n      let fillColor = \"red\";\n\n      if (d.status === \"Discharged\") {\n        fillColor = \"green\";\n      } else if (d.status === \"Deceased\") {\n        fillColor = \"black\";\n      }\n\n      d.x = Math.cos(locAngle) * dist + width / 2;\n      d.y = Math.sin(locAngle) * dist + height / 2;\n      d.fill = fillColor;\n\n      return d;\n    });\n\n    setNodes(dataNodes);\n  }, [data, height, width]);\n\n  useEffect(() => {\n    if (displayState === STATES.BROWNIAN) {\n      brownian();\n    } else if (displayState === STATES.GRAPH) {\n      dailyGraph();\n    } else if (displayState === STATES.CIRCLE) {\n      gatherNodes();\n    } else if (displayState === STATES.RADIAL) {\n      radialGraph();\n    } else if (displayState === STATES.LINKS) {\n      linkGraph();\n    } else if (displayState === STATES.SINGAPORE) {\n      singapore();\n    }\n  }, [displayState, nodes]);\n\n  // Debug purposes, to toggle the states.\n  const clickHandler = (e) => {\n    e.preventDefault();\n\n    const newDisplayState = Object.values(STATES)[\n      (stateKeys.indexOf(displayState) + 1) % stateKeys.length\n    ];\n\n    setDisplayState(newDisplayState);\n  };\n\n  // Handles the reset of the state\n  const resetState = () => {\n    if (timer) timer.stop();\n    if (simulation) simulation.stop();\n\n    d3.select(xAxisRef.current).selectAll(\"*\").remove();\n    d3.select(yAxisRef.current).selectAll(\"*\").remove();\n  };\n\n  // This is the state where all the nodes are gathered in a circle.\n  // This is achieved with a force that gathers all the nodes to the center,\n  // counter-balanced by a force that spreads them out.\n  // Force values were determined empirically, might have to be recalibrated\n  // with more data.\n  const gatherNodes = (dataNodes = nodes) => {\n    resetState();\n    const replusion = d3.forceManyBody().strength(-2);\n\n    const yForce = d3\n      .forceY()\n      .y(height / 2)\n      .strength(0.1);\n    const xForce = d3\n      .forceX()\n      .x(width / 2)\n      .strength(0.1);\n\n    const sim = d3.forceSimulation(nodes);\n    sim.force(\"y\", yForce).force(\"x\", xForce);\n    sim.force(\"replusion\", replusion);\n\n    sim.alphaMin(0.1).velocityDecay(0.4);\n    sim.on(\"tick\", () => {\n      const context = ref.current.getContext(\"2d\");\n\n      context.clearRect(0, 0, width, height);\n      D3Dots.drawDots(context, dataNodes);\n    });\n\n    setSimulation(sim);\n  };\n  // Graph of the daily numbers, sorted by their ids\n  // TODO: might consider using animations rather than force?\n  const dailyGraph = (dataNodes = nodes) => {\n    resetState();\n\n    const xScale = d3.scaleTime(\n      d3.extent(dataNodes.map((d) => d.dateConfirmed)),\n      [PADDING, width - PADDING]\n    );\n    const yScale = d3.scaleLinear(d3.extent(dataNodes.map((d) => d.dayNo)), [\n      height - PADDING,\n      PADDING,\n    ]);\n\n    const yForce = d3.forceY().y(({ dayNo }) => yScale(dayNo));\n    const xForce = d3.forceX().x(({ dateConfirmed }) => xScale(dateConfirmed));\n\n    const sim = d3.forceSimulation(nodes);\n\n    sim.force(\"y\", yForce).force(\"x\", xForce);\n    sim.alphaMin(0.005).velocityDecay(0.4);\n    sim.on(\"tick\", () => {\n      const context = ref.current.getContext(\"2d\");\n\n      context.clearRect(0, 0, width, height);\n      D3Axes.drawAxes(\n        d3.select(xAxisRef.current),\n        d3.select(yAxisRef.current),\n        xScale\n      );\n      D3Dots.drawDots(context, dataNodes);\n    });\n\n    setSimulation(sim);\n  };\n\n  // Radial graph of cases, with each band representing a week.\n  // Utility wise may not be the best, since it takes up a lot of space,\n  // but could be a powerful addition.\n  const radialGraph = (dataNodes = nodes) => {\n    resetState();\n\n    const [firstDay, lastDay] = d3.extent(\n      dataNodes.map((d) => d.dateConfirmed)\n    );\n\n    const weeks = new Array(Math.ceil((lastDay - firstDay) / WEEK));\n\n    // 1. Calculate the # of the case in that particular week, assign it the angle\n    // Skip if it was already set\n    if (!dataNodes[0].week) {\n      dataNodes.forEach((d) => {\n        const index = Math.floor((d.dateConfirmed - firstDay) / WEEK);\n        d.week = index;\n        d.weekNo = (weeks[index] || 0) + 1;\n        weeks[index] = d.weekNo;\n      });\n\n      dataNodes.forEach((d) => {\n        d.weekAngle = (d.weekNo / weeks[d.week]) * 2 * Math.PI;\n      });\n      console.log(weeks);\n    }\n\n    // 2. Plot using the angle above\n\n    const rScale = d3.scaleTime(\n      [0, weeks.length - 1],\n      // The 15 serves as a padding so the cases in the first week will not be clustered\n      [15, (height - 2 * PADDING) / 2]\n    );\n\n    const ANIMATION_SPAN = 500;\n\n    // Set the starting parameters\n    dataNodes.forEach((node) => {\n      node.startX = node.x;\n      node.startY = node.y;\n      node.targetX = rScale(node.week) * Math.cos(node.weekAngle) + width / 2;\n      node.targetY = rScale(node.week) * Math.sin(node.weekAngle) + height / 2;\n    });\n\n    const newTimer = d3.timer((elapsed) => {\n      dataNodes.forEach((node) => {\n        let ratio = elapsed / ANIMATION_SPAN;\n        if (ratio > 1) ratio = 1;\n\n        node.x = (node.targetX - node.startX) * ratio + node.startX;\n        node.y = (node.targetY - node.startY) * ratio + node.startY;\n      });\n\n      const context = ref.current.getContext(\"2d\");\n\n      context.clearRect(0, 0, width, height);\n\n      weeks.forEach((_, i) => {\n        context.beginPath();\n        context.ellipse(\n          width / 2,\n          height / 2,\n          rScale(weeks.length - i - 0.5),\n          rScale(weeks.length - i - 0.5),\n          0,\n          0,\n          2 * Math.PI\n        );\n        i % 2 === 0\n          ? (context.fillStyle = \"#eeeeee\") // Fill the odd rings to highlight the weeks\n          : (context.fillStyle = \"white\");\n        context.fill();\n      });\n      D3Dots.drawDots(context, dataNodes);\n\n      if (elapsed > ANIMATION_SPAN) newTimer.stop();\n    });\n\n    setTimer(newTimer);\n  };\n\n  // Graph to show the links between different cases, as plotted against time.\n  // The data here is pre-processed in process.js, and is plotted as a d3.tree()\n  // with invisible nodes.\n  // Unfortunately the resulting graph appears very cramped, and will likely be so,\n  // and most links are not very useful anyways. Still, the manipulation used to\n  // get to this point was interesting.\n  const linkGraph = (dataNodes = nodes) => {\n    resetState();\n\n    const xScale = d3.scaleTime(\n      d3.extent(dataNodes.map((d) => d.dateConfirmed)),\n      [PADDING, width - PADDING]\n    );\n    const yScale = d3.scaleLinear([0, 1000], [PADDING, height - PADDING]);\n\n    const yForce = d3\n      .forceY()\n      .y((node) => (node.treeY ? yScale(node.treeY) : -PADDING));\n    const xForce = d3.forceX().x((node) => xScale(node.dateConfirmed));\n\n    D3Axes.drawAxes(\n      d3.select(xAxisRef.current),\n      d3.select(yAxisRef.current),\n      xScale\n    );\n\n    const sim = d3.forceSimulation(nodes);\n    sim.force(\"x\", xForce).force(\"y\", yForce);\n    sim.alphaMin(0.01).velocityDecay(0.4);\n    sim.on(\"tick\", () => {\n      const context = ref.current.getContext(\"2d\");\n\n      context.clearRect(0, 0, width, height);\n      D3Dots.drawDots(context, dataNodes);\n      D3Dots.drawHorizontalLinks(context, dataNodes);\n    });\n    setSimulation(sim);\n  };\n\n  // Simulation of brownian motion. The idea behind this was to give a visual\n  // sense of people moving around and infecting people, or to highlight sheer\n  // numbers.\n  const brownian = (dataNodes = nodes) => {\n    resetState();\n    dataNodes.forEach((node) => {\n      node.vx = (Math.random() - 0.5) * 5;\n      node.vy = (Math.random() - 0.5) * 5;\n    });\n\n    const sim = d3.forceSimulation(nodes);\n    // Could use a d3-force-bounce here. Opted to remove it as it was draining\n    // on the resources.\n    sim.force(\n      \"container\",\n      d3ForceSurface().surfaces([\n        {\n          from: { x: 0, y: 0 },\n          to: { x: 0, y: height },\n        },\n        {\n          from: { x: 0, y: 0 },\n          to: { x: width, y: 0 },\n        },\n        {\n          from: { x: 0, y: height },\n          to: { x: width, y: height },\n        },\n        {\n          from: { x: width, y: 0 },\n          to: { x: width, y: height },\n        },\n      ])\n    );\n    sim.velocityDecay(0).alphaMin(0);\n    sim.on(\"tick\", () => {\n      const context = ref.current.getContext(\"2d\");\n\n      context.clearRect(0, 0, width, height);\n      D3Dots.drawDots(context, dataNodes);\n    });\n    setSimulation(sim);\n  };\n\n  // The inspiration here was originally to use brownian motion in a Singapore\n  // map container to demonstrate people moving about in Singapore. Unfortunately\n  // this proved too computationally intensive, and the current function was\n  // repurposed to animate the dots into pre-computed positions to form the\n  // silhouette of Singapore.\n  const singapore = (dataNodes = nodes) => {\n    resetState();\n\n    const ANIMATION_SPAN = 300; // Animation span in ms\n\n    // sgX and sgY were pre-computed in process.js\n    const heightExtent = d3.extent(dataNodes.map((d) => d.sgY));\n    const widthExtent = d3.extent(dataNodes.map((d) => d.sgX));\n\n    // get the height and width of the silhouette.\n    const heightSg = heightExtent[1] - heightExtent[0];\n    const widthSg = widthExtent[1] - widthExtent[0];\n\n    const scale = Math.min(\n      (height - 2 * PADDING) / heightSg,\n      (width - 2 * PADDING) / widthSg\n    );\n\n    const xOffset = (width - widthSg * scale) / 2;\n    const yOffset = (height - heightSg * scale) / 2;\n\n    // Set the starting parameters\n    dataNodes.forEach((node) => {\n      node.startX = node.x;\n      node.startY = node.y;\n      node.targetX = node.sgX * scale + xOffset;\n      node.targetY = node.sgY * scale + yOffset;\n    });\n\n    const newTimer = d3.timer((elapsed) => {\n      dataNodes.forEach((node) => {\n        let ratio = elapsed / ANIMATION_SPAN;\n        if (ratio > 1) ratio = 1;\n\n        node.x = (node.targetX - node.startX) * ratio + node.startX;\n        node.y = (node.targetY - node.startY) * ratio + node.startY;\n      });\n\n      const context = ref.current.getContext(\"2d\");\n\n      context.clearRect(0, 0, width, height);\n      D3Dots.drawDots(context, dataNodes);\n\n      if (elapsed > ANIMATION_SPAN) newTimer.stop();\n    });\n\n    setTimer(newTimer);\n  };\n\n  return (\n    <>\n      <svg style={{ width: \"100%\", height: \"100%\", position: \"absolute\" }}>\n        <g ref={xAxisRef} transform={`translate(0,${height - PADDING})`} />\n        <g ref={yAxisRef} transform={`translate(${PADDING},${PADDING})`} />\n      </svg>\n      <canvas\n        width={width}\n        height={height}\n        onClick={(e) => clickHandler(e)}\n        ref={ref}\n        style={{ position: \"absolute\" }}\n      />\n    </>\n  );\n};\n\nexport default Dots;\n","import React from \"react\";\nimport Dots from \"./Dots\";\nimport data from \"../data/processedData.json\";\n\nconst Visualization = () => {\n  return (\n    <div>\n      <Dots data={data} height={window.innerHeight} width={window.innerWidth} />\n    </div>\n  );\n};\n\nexport default Visualization;\n","import React from \"react\";\nimport Visualization from \"./visualizations/Visualization\";\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <Visualization />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}